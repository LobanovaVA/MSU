\documentclass[a4paper,12pt]{article}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\usepackage[dvipsnames]{xcolor}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{enumitem}
\usepackage{cmap}
\usepackage{hyperref}
\usepackage{mdframed}
\usepackage{anyfontsize}
\usepackage{algorithm2e}
\usepackage{listings}



%\setlist{nolistsep}

\newtheorem*{task*}{Задача}
\newtheorem*{solve*}{Идея решения}
\newtheorem*{theorem*}{Теорема}

\title{\textbf{Решение системы линейных уравнений методом Холецкого}}
\author{Лобанова Валерия, группа 310}
\date{ }

\begin{document}
\maketitle
\thispagestyle{empty} 
\newpage
\tableofcontents{}



% Глава1 
\newpage
\section{Введение}
\subsection{Постановка задачи. Разложение Холецкого}
    \begin{task*}
        Найти решение системы линейных уравнений $A x=b$, где \\
        $A $ --- симметричная вещественнозначная матрицы размера $n \times n$, \\
        $b$ --- известный вектор размера $n$, \\
        $x$ --- неизвестный вектор.
    \end{task*}
    
    \begin{proof} [Идея решения]
        Поиск решения будет осуществляться с помощью разложения 
        Холецкого матрицы $A=R^T DR$,  где \\
        $R$ --- верхнетреугольная матрица, \\
        $D$ --- диагональная матрица с $1$ или $-1$  на диагонали.\\
        Найдем такое $y$, что $R^Ty=b$ и затем из условия $DRx=y$ найдем $x$.
    \end{proof}
    
    \begin{theorem*}
        Пусть матрица $A$ --- самосопряженная и все ее угловые миноры отличны
        от нуля. Тогда существует матрица $R=(r_{ij}) \in RT(n)$  с вещественными 
        положительными элементами на главной диагонали и диагональная матрица
        $D$ с вещественными равными по модулю единице дигональными элементами
        такие, что $A=R^T DR$.
    \end{theorem*}
    
    \begin{proof} [Решение задачи]
        Применим точечный метод Холецкого для поиска матрицы $R$.
        Элементы $d_{ii}$, $r_{ii}$ ,$r_{ij}$ могут быть вычиcлены по 
        следующим формулам:
        \begin{equation} \label{dot}
             d_{ii} = sgn(a_{ii}-\sum_{k=1}^{i-1}|r_{ki}|^2d_{kk}),\  i=1,...,n,
        \end{equation}
        $$ 
            r_{ii} = \sqrt{\Big|a_{ii}-\sum_{k=1}^{i-1}|r_{ki}|^2d_{kk}\Big|},\  i=1,...,n, 
        $$
        $$ 
            r_{ij} = (r_{ii}d_{ii})^{-1}
                    (a_{ij}-\sum_{k=1}^{i-1}r_{ki}d_{kk}r_{kj}),\  
                    i<j, \ i,j=1,...,n,
        $$
    \end{proof}


\newpage
\subsection{Оценка сложности алгоритма построения верхнетреугольной матрицы
в разложении Холецкого}

    Из формул~\eqref{dot} следует, что для вычисления элемента $d_{ii}$, $i=1,...,n$\\
    требуется $2 (i-1)$ операций (умножение на $d_{ii}$ за операцию не считаем). \\
    Следовательно, вычисление всех элементов матрицы $D$ требует \\
    $$
        \sum_{i=1}^n 2(i-1) = n(n-1) = O(n^2), \
        n \rightarrow \infty 
        \quad \text{операций.}
    $$
    
    Для вычисления элемента $r_{ii}$ требуется $2 (i-1) + 1 = 2i - 1$ операций 
    (учитываем 1 операцию извлечения корня). \\
    При фиксированном $i=1,...,n$ вычисление элементов $r_{ij}$ для всех 
    $j=i+1,..n$ по формулам~\eqref{dot} требует 
    $$\sum_{j=i+1}^n(2i - 1) = (n-i)(2i - 1) \quad \text{операций.}$$ 

    Таким образом нахождение матрицы $R$ требует 
    $$
        \sum_{i=1}^n(n-i)(2i - 1)+(2i - 1) = 
        \frac{2n^2 + 3n + 1}6  =  \frac{n^3}3 + O(n^2), \
        n \rightarrow \infty \
        \quad \text{операций.}
    $$



% Глава2
\newpage
\section{Блочный метод Холецкого}
\subsection{Описание блочного метода Холецкого}
    Разобьем матрицу $A$ на блоки $(A_{ij})$ размера $m \times m$, где $m < n$ и 
    в случае когда $m \nmid n \Rightarrow n = m*k + l, l \neq 0$, 
    крайние блоки могут иметь размеры $m \times l$, $l \times m$, $l \times l$. 
    Матрицы $R$ и $D$ можно также искать в виде блочных матриц. \\
    
    Из формул $A = R^TDR$ и~\eqref{dot} ясно, что формулы для нахождения блоков 
    матрицы $R$ имеют вид:
    \begin{equation} \label{block_i}
        R_{ii}^T D_i R_{ii}  = A_{ii} - 
        \sum_{j=1}^{i-1} R_{ji}^T D_j R_{ji},\  
        i=1,...,k,
     \end{equation}
    $$
        R_{ii}^T D_i R_{is}  = A_{is} - 
        \sum_{j=1}^{i-1} R_{ji}^T D_j R_{js},\  
        i, s = 1,...,k, \ i < s
    $$
    \begin{equation} \label{block_is}
        R_{is} = D_i(R_{ii}^T)^{-1}(A_{is} - 
        \sum_{j=1}^{i-1} R_{ji}^T D_j R_{js}),\  
        i, s = 1,...,k, \ i < s
    \end{equation}
    
    Тем самым сначала получаются блоки $R_{ii}$ и $D_i$ точечным разложением 
    Холецкого из формулы~\eqref{block_i}, а затем используя~\eqref{block_is} 
    вычисляются $R_{is}$ для $s = i+1,...n$.


\subsection{Описание решения систем $R^T y = b$ и $DRx = y$}
    \hypertarget{calc_y}{Для} 
    решения $R^T y = b$ представляем, что $R^T$ на самом деле не транспонированная
    и лежит в памяти как $R$, но работаем с ней как с транспонированной. 
    Тогда получаем следующий алгоритм:
    
    \begin{verbatim}
for (j = 0; j < n; j++) 
  {
    sum = 0;
    for (i = 0; i < j; i++)
      sum += Y[i] * R_{ij};
    
    Y[j] = (B[j] - sum) / R_{jj};
  }
    \end{verbatim}

    \hypertarget{calc_x}{Для} 
    решения $DRx = y$ важно учитывать, что умножение на матрицу $D$ можно производить после подсчета суммы.
    
    \begin{verbatim}
for (i = n - 1; i >= 0; i--)
 {
    sum = 0;
    for (j = n - 1; j > i; j--)
        sum += X[j] * R_{ij};
    
    X[i] = D[i] * (Y[i] - sum * D[i]) / R_{ii};
 }
    \end{verbatim}


\subsection{Хранение матриц}
    Так как матрица $A$ симметричная, то логично хранить не всю матрицу, 
    а только верхнюю ее часть над главной диагональю и саму диагональ. 
    $$ a_{00} = a [0]; \ a_{11} = a [n]; \ a_{22} = a [n + (n-1)]; ... $$
    $$ a_{ii} = a [\,\sum_{j=0}^{i-1}(n-j)] = a [i * (2 * n - i +1) / 2];  $$
    $$ 
        a_{is} = a [\,\sum_{j=0}^{i-1}(n-j)] = a [i * (2 * n - i +1) / 2 + (s - i)], 
        \; i \leq s  
    $$
    
    У матрицы $D$ хранить нужно только диагональ в массиве длины $n$.\\
    
    При вычислении матрицы $R$ элементы $R_{is}$ можно записывать сразу на место $A_{is}$,
    так как $A_{is}$ больше не будет использоваться. 
    
    
\newpage
\subsection{Оценка сложности в алгоритме построения верхнетреугольной 
матрицы в блочном разложении Холецкого}
    Если известно количество операций в случае $l = 0$, то количество 
    операций при $l \neq 0$ можно оценить сверху, заменив в оценке $k$ на $k + 1$.  \\
    
    Начнём с оценки количества операций для $R_{ji}^T D_j R_{js}$,\\
    чтобы не путаться в индексах рассмотим это произвдение как $R^TDR$, тогда
    $$ (R^TDR)_{ij} = \sum_{k=1}^{min(i,j)} r_{ki} d_k r_{kj} $$
    здесь $min(i,j) - 1$ аддитивных и $min(i,j)$ мультипликативных операций, 
    то есть всего $2min(i,j) - 1$ операций для одного элемента 
    (по аналогии с неблочным методом умножение на $d_i$ за операцию не считаем). \\
    
    Тогда для вычисления $R_{ji}^T D_j R_{js}$ требуется 
    $$
        \sum_{i=1}^m \sum_{j=1}^m (2min(i,j) - 1) =
        \sum_{i=1}^m \sum_{j=1}^i (2j - 1) + 
        \sum_{i=1}^m \sum_{j=i+1}^m (2i - 1) = $$$$
        \frac{m(m+1)(2m+1)}6 + \frac{m(2m^2-3m+1)}6 = 
        \frac{m(2m^2+1)}3 
    $$
    
    Обозначим как $ Mult(m) = (2m^3+m)/3 $. \\ \\
    
    Для вычисления $A_{is} - \sum_{k=1}^{i-1}R_{ji}^T D_j R_{js}$ требуется: 
    $$
        H(i,m) = 
        (i-1)(Mult(m)+m^2) = 
        (i-1)(2m^3+3m^2+m)/3 
        \quad \text{операций.}
    $$  
    Сложность разложения Холецкого $Chol(m) = m^3/3$. \\
    Cложность вычисления блока $R_{ii}$ и $D_i$ : $H(i,m) + Chol(m)$ \\
    \hypertarget{block_border}{Сложность вычисления всех диагональных блоков:}
    $$ 
        S_1(n,m,k) = 
        \sum_{i=1}^k (H(i,m) + Chol(m)) =
        n(2mn + 3n + k - 3m -1)/6
    $$
    \\
    
    Умножение на треугольную матрицу требует $Y(m)=m^3$ операций.
    Здесь имеется ввиду умножение на $(R_{ii}^T)^{-1}$ в формуле~\eqref{block_is}. 
    Подсчёт обратной к $R_{ii}^T$ учтёем позже, так как это вычисление выполняется 
    1 раз при подсчете всей строки. \\
    
    Итак, сложность вычисления недиагонального блока $R_{ij}$:
    $$ 
        R(i,m) = H(i,m) + Y(m) =
        (i-1)(2m^3+3m^2+m)/3 + m^3
    $$
    
    Cложность вычисления всех недиагональных блоков $R$:
    $$ 
        S_2(n,m,k) = 
        \sum_{i=1}^k\sum_{s=i+1}^k R(i,m) =
        n(k-1)(2mn+3n+k+5m^2-6m-2)/18
    $$
    
    Для вычисления строки - $R_{ij}$ при фиксированном $i$ требуется $(R_{ii}^T)^{-1}$,
    следовательно нужно $(k-1)$ раз найти обратную матрицу за \\
    $S_3(n, m) = (k-1)Chol(m) = (k-1)m^3/3$ операций. \\
    
    Итак, нахождение всех блоков $R_{is}$ требует
    $$
        S(n, m)= S_1 + S_2 + S_3 = 
        \frac{n(2mn + 3n + k - 3m -1)}6 + $$$$ +
        \frac{n(k-1)(2mn+3n+k+5m^2-6m-2)}{18} +
        \frac{(k-1)m^3}3 = $$$$ =
        \frac{n(2n^2+m^2+9mn-3m-1+3nk+k^2)}{18} - \frac{m^3}3 = $$$$ =
        \boxed {
            \frac{n^3}9 + \frac{nm^2}{18} + \frac{n^2m}2 - \frac{nm}6 -
            \frac{n}{18} + \frac{n^3}{6m} + \frac{n^3}{18m^2} - \frac{m^3}3  }
    $$
    
    $$ 
        S(n,n) =
        \frac{n^3}9 + \frac{n^3}{18} + \frac{n^3}2 - \frac{n^2}6 - 
        \frac{n}{18} + \frac{n^2}6 + \frac{n}{18} - \frac{n^3}3 = 
        \frac{n^3}3
    $$
    $$
        S(n,1) = 
        \frac{n^3}9 + \frac{n}{18} + \frac{n^2}3 - \frac{n}6 -
        \frac{n}{18} + \frac{n^3}6 + \frac{n^3}{18} - \frac{1}3 =
        \frac{n^3}3 + \frac{n^2}3 - \frac{n}6
    $$
    
    $$
        \boxed {
            S(n,n) = \frac{n^3}3 \quad 
            S(n,1) = \frac{n^3}3 + O(n^2),\ n \to \infty   }
    $$
    
    


% Глава3
\newpage
\section{Параллельный блочный метод Холецкого}
\subsection{Описание параллельного блочного метода Холецкого}
    Из формул~\eqref{block_i} и~\eqref{block_is} видно, что после вычисления диагольного 
    блока и его обращения все блоки вне диагонали можно искать в любом порядке в 
    контексте текущей строки, при чём для вычисления блока $R_{is}$ требуются блоки 
    из столбцов $i$ и $s$, находящиеся строго в предыдущих строках. \\
    
    Пусть $p$ --- количество потоков и потоки никак не мешают друг другу. 
    Принадлежность столбца потоку определяется так:
    $t$-ый поток обрабатывает столбцы с номерами $t + zp$, где $z \in \mathbb{Z}$. \\
    
    Таким образом, предлагается 
    \hypertarget{paral_alg}{ледующий параллельный алгоритм}, 
    в котором каждый поток считает блоки только из своего столбца. 

\begin{verbatim}
for (i = 0; i < block_lim; i++)
  {
    R_ii_tmp = A_{ii};
    calculate_diag_block R_{ii};
    inverse_upper_matrix R_{ii};
    
    if (i % p < t_id)
        j = i - (i % p) + t_id;
    else
        j = i - (i % p) + p + t_id;
        
    for (; j < block_lim; j += p)
      {
        R_ij_tmp = A_{ij};
        calculate_block R_{ij};
        A_{ij} = R_ij_tmp;
      }
    
    Barrier ();
    
    if (i % p == t_id)
        A_{ii} = R_ii_temp;
  }
\end{verbatim}

\newpage
\subsection{Описание параллельного решения систем $R^T y = b$ и $DRx = y$}
    Сделаем параллельным описанный выше 
    \hyperlink{calc_y}{линейный алгоритм решения системы $R^T y = b$}.   
    
    Каждый поток подсчитывает свой $y[i]$ по следующему правилу:\\
    если $i = t \pmod{p}$, то поток с номером $t$ вычисляет $y[i]$.

\begin{verbatim}
for (j = 0 + t_id; j < n; j += p)
  {
    sum = 0;
    for (i = 0; i <= j - p; i++)
      sum += Y[i] * R_{ki};
        
    pthread_mutex_lock (mut);
    while (*elems_done < i)
      pthread_cond_wait (cond, mut);
    pthread_mutex_unlock (mut);
      
    for (; i < j; i++)
      sum += Y[i] * R_{ij};

    Y[j] = (B[j] - sum) / R_{jj};
      
    pthread_mutex_lock (mut);
    (*elems_done)++;
    pthread_cond_broadcast (cond);
    pthread_mutex_unlock (mut);
  }
\end{verbatim}

    Аналогично получается параллельный алгоритм 
    \hyperlink{calc_x}{для решения системы $DRx = y$}.
    Каждый поток подсчитывает свой $x[i]$ по следующему правилу:
    если $i = t \pmod{p}$, то поток с номером $t$ вычисляет $y[n - 1 - i]$.

\begin{verbatim}
for (i = n - 1 - t_id; i >= 0; i -= p)
  {
    sum = 0;
    for (j = n - 1; j >= i + p; j--)
      sum += X[j] * R_{ij};
        
    pthread_mutex_lock (mut);
    while (*elems_done < n - 1 - i)
      pthread_cond_wait (cond, mut);
    pthread_mutex_unlock (mut);
      
    for (; j > i; j--)
      sum += X[j] * R_{ij};

    X[i] = D[i] * (B[i] - sum * D[i]) / R_{ii};
      
    pthread_mutex_lock (mut);
    (*elems_done)++;
    pthread_cond_broadcast (cond);
    pthread_mutex_unlock (mut);
  }
\end{verbatim}


\subsection{Оценка числа точек синхронизаций}
    Считаем, что $n = mk + l,\; l = 0$.\\
    
    Разложение матрицы методом Холецкого требует $k$ барьеров.
    При решении систем $R^T y = b$ и $DRx = y$ используется по $n$ точек синхронизации.
    Причем каждый поток использует только свою память, а синхронизация осуществляется 
    за счет условной переменной, где условие - это количество уже вычисленных элементов.\\
    
    Таким образом весь алгоритм требует 
    $\boxed {\frac{n}{m} + 2n}$ точек синхронизаций.
    

\newpage
\subsection{Оценка сложности в алгоритме построения верхнетреугольной матрицы
в параллельном блочном разложении Холецкого}
    Из \hyperlink{paral_alg}{приведенного выше алгоритма} видно, что все потоки 
    вычисляют совпадающие диагональные блоки и обратные к ним, поэтому 
    $$
        S_1(n,m,p) = S_1(n,m) \quad \text{и} \quad S_3(n,m,p) = S_3(n,m)
    $$
    Эти формулы из \hyperlink{block_border}{оценки блочного алгоритма.} \\
    
    Вычисление внедиагональных блоков происходит полностью параллельно, поэтому 
    $ S_2(n,m,p) = S_2(n,m)/p $ \\

    Итак, 
    $$
        S(n,m,p) = S_1 + \frac{S_2}{p} + S_3 = 
        \frac{n(2mn + 3n + k - 3m -1)}6 \,+ $$$$ +\,
        \frac{n(k-1)(2mn+3n+k+5m^2-6m-2)}{18p} +
        \frac{(k-1)m^3}3 = $$$$ =
        \frac{n^3}9 + \frac{n^2m}{6p} + \frac{n^2m}{3} +
        \frac{nm^2}3 - \frac{5nm^2}{18p} - \frac{m^3}3 +
        \frac{n^2}2 - \frac{n^2}{2p} - \frac{nm}2 + \frac{nm}{3p} - $$$$ -
        \frac{n}6 + \frac{n}{9p} + \frac{n^3}{6pm} + \frac{n^3}{18pm^2} +
        \frac{n^2}{6m} - \frac{n^2}{6pm}
    $$ \\
    
    Причем $S(n,m,1) = S(n,m)$

\end{document}
