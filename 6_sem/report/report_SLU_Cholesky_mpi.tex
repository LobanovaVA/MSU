\documentclass[a4paper,12pt]{article}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\usepackage[dvipsnames]{xcolor}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{enumitem}
\usepackage{cmap}
\usepackage{hyperref}
\usepackage{mdframed}
\usepackage{anyfontsize}
\usepackage{algorithm2e}
\usepackage{listings}



%\setlist{nolistsep}

\newtheorem*{task*}{Задача}
\newtheorem*{solve*}{Идея решения}
\newtheorem*{theorem*}{Теорема}

\title{\textbf{Решение системы линейных уравнений методом Холецкого}}
\author{Лобанова Валерия, группа 310}
\date{ }

\begin{document}
\maketitle
\thispagestyle{empty} 
\newpage
\tableofcontents{}



% Глава1 
\newpage
\section{Введение}
\subsection{Постановка задачи. Разложение Холецкого}
    \begin{task*}
        Найти решение системы линейных уравнений $A x=b$, где \\
        $A $ --- симметричная вещественнозначная матрицы размера $n \times n$, \\
        $b$ --- известный вектор размера $n$, \\
        $x$ --- неизвестный вектор.
    \end{task*}
    
    \begin{proof} [Идея решения]
        Поиск решения будет осуществляться с помощью разложения 
        Холецкого матрицы $A=R^T DR$,  где \\
        $R$ --- верхнетреугольная матрица, \\
        $D$ --- диагональная матрица с $1$ или $-1$  на диагонали.\\
        Найдем такое $y$, что $R^Ty=b$ и затем из условия $DRx=y$ найдем $x$.
    \end{proof}
    
    \begin{theorem*}
        Пусть матрица $A$ --- самосопряженная и все ее угловые миноры отличны
        от нуля. Тогда существует матрица $R=(r_{ij}) \in RT(n)$  с вещественными 
        положительными элементами на главной диагонали и диагональная матрица
        $D$ с вещественными равными по модулю единице дигональными элементами
        такие, что $A=R^T DR$.
    \end{theorem*}
    
    \begin{proof} [Решение задачи]
        Применим точечный метод Холецкого для поиска матрицы $R$.
        Элементы $d_{ii}$, $r_{ii}$ ,$r_{ij}$ могут быть вычиcлены по 
        следующим формулам:
        \begin{equation} \label{dot}
             d_{ii} = sgn(a_{ii}-\sum_{k=1}^{i-1}|r_{ki}|^2d_{kk}),\  i=1,...,n,
        \end{equation}
        $$ 
            r_{ii} = \sqrt{\Big|a_{ii}-\sum_{k=1}^{i-1}|r_{ki}|^2d_{kk}\Big|},\  i=1,...,n, 
        $$
        $$ 
            r_{ij} = (r_{ii}d_{ii})^{-1}
                    (a_{ij}-\sum_{k=1}^{i-1}r_{ki}d_{kk}r_{kj}),\  
                    i<j, \ i,j=1,...,n,
        $$
    \end{proof}


\newpage
\subsection{Оценка сложности алгоритма построения верхнетреугольной матрицы
в разложении Холецкого}

    Из формул~\eqref{dot} следует, что для вычисления элемента $d_{ii}$, $i=1,...,n$\\
    требуется $2 (i-1)$ операций (умножение на $d_{ii}$ за операцию не считаем). \\
    Следовательно, вычисление всех элементов матрицы $D$ требует \\
    $$
        \sum_{i=1}^n 2(i-1) = n(n-1) = O(n^2), \
        n \rightarrow \infty 
        \quad \text{операций.}
    $$
    
    Для вычисления элемента $r_{ii}$ требуется $2 (i-1) + 1 = 2i - 1$ операций 
    (учитываем 1 операцию извлечения корня). \\
    При фиксированном $i=1,...,n$ вычисление элементов $r_{ij}$ для всех 
    $j=i+1,..n$ по формулам~\eqref{dot} требует 
    $$\sum_{j=i+1}^n(2i - 1) = (n-i)(2i - 1) \quad \text{операций.}$$ 

    Таким образом нахождение матрицы $R$ требует 
    $$
        \sum_{i=1}^n(n-i)(2i - 1)+(2i - 1) = 
        \frac{2n^2 + 3n + 1}6  =  \frac{n^3}3 + O(n^2), \
        n \rightarrow \infty \
        \quad \text{операций.}
    $$



% Глава2
\newpage
\section{Блочный метод Холецкого}
\subsection{Описание блочного разложения Холецкого}
    Разобьем матрицу $A$ на блоки $(A_{ij})$ размера $m \times m$, где $m < n$ и 
    в случае когда $m \nmid n \Rightarrow n = m*k + l, l \neq 0$, 
    крайние блоки могут иметь размеры $m \times l$, $l \times m$, $l \times l$. 
    Матрицы $R$ и $D$ можно также искать в виде блочных матриц. \\
    
    Из формул $A = R^TDR$ и~\eqref{dot} ясно, что формулы для нахождения блоков 
    матрицы $R$ имеют вид:
    \begin{equation} \label{block_i}
        R_{ii}^T D_i R_{ii}  = A_{ii} - 
        \sum_{j=1}^{i-1} R_{ji}^T D_j R_{ji},\  
        i=1,...,k,
     \end{equation}
    $$
        R_{ii}^T D_i R_{is}  = A_{is} - 
        \sum_{j=1}^{i-1} R_{ji}^T D_j R_{js},\  
        i, s = 1,...,k, \ i < s
    $$
    \begin{equation} \label{block_is}
        R_{is} = D_i(R_{ii}^T)^{-1}(A_{is} - 
        \sum_{j=1}^{i-1} R_{ji}^T D_j R_{js}),\  
        i, s = 1,...,k, \ i < s
    \end{equation}
    
    Тем самым сначала получаются блоки $R_{ii}$ и $D_i$ точечным разложением 
    Холецкого из формулы~\eqref{block_i}, а затем используя~\eqref{block_is} 
    вычисляются $R_{is}$ для $s = i+1,...n$.


\subsection{Описание решения систем $R^T y = b$ и $DRx = y$}
    \hypertarget{calc_y}{Для} 
    решения $R^T y = b$ представляем, что $R^T$ на самом деле не транспонированная
    и лежит в памяти как $R$, но работаем с ней как с транспонированной. 
    Тогда получаем следующий алгоритм:
    
\begin{verbatim}
for (j = 0; j < block_lim; j++) 
  {
    sum = 0;
    for (i = 0; i < j; i++)
      sum += Y[i] * R_{ij};
    
    Y[j] = (B[j] - sum) / R_{jj};
  }
\end{verbatim}

    \hypertarget{calc_x}{Для} 
    решения $DRx = y$ важно учитывать, что умножение на матрицу $D$ можно 
    производить после подсчета суммы.
    
\begin{verbatim}
for (i = block_lim - 1; i >= 0; i--)
 {
    sum = 0;
    for (j = block_lim - 1; j > i; j--)
        sum += X[j] * R_{ij};
    
    X[i] = D[i] * (Y[i] - sum * D[i]) / R_{ii};
 }
\end{verbatim}


\subsection{Хранение матриц}
    Так как матрица $A$ симметричная, то логично хранить не всю матрицу, 
    а только верхнюю ее часть над главной диагональю и саму диагональ. 
    $$ a_{00} = a [0]; \ a_{11} = a [n]; \ a_{22} = a [n + (n-1)]; ... $$
    $$ a_{ii} = a [\,\sum_{j=0}^{i-1}(n-j)] = a [i * (2 * n - i +1) / 2];  $$
    $$ 
        a_{is} = a [\,\sum_{j=0}^{i-1}(n-j)] = a [i * (2 * n - i +1) / 2 + (s - i)], 
        \; i \leq s  
    $$
    
    У матрицы $D$ хранить нужно только диагональ в массиве длины $n$.\\
    
    При вычислении матрицы $R$ элементы $R_{is}$ можно записывать сразу на место $A_{is}$,
    так как $A_{is}$ больше не будет использоваться. 
    
    
\newpage
\subsection{Оценка сложности в алгоритме построения верхнетреугольной 
матрицы в блочном разложении Холецкого}
    Если известно количество операций в случае $l = 0$, то количество 
    операций при $l \neq 0$ можно оценить сверху, заменив в оценке $k$ на $k + 1$.  \\
    
    Начнём с оценки количества операций для $R_{ji}^T D_j R_{js}$,\\
    чтобы не путаться в индексах рассмотим это произвдение как $R^TDR$, тогда
    $$ (R^TDR)_{ij} = \sum_{k=1}^{min(i,j)} r_{ki} d_k r_{kj} $$
    здесь $min(i,j) - 1$ аддитивных и $min(i,j)$ мультипликативных операций, 
    то есть всего $2min(i,j) - 1$ операций для одного элемента 
    (по аналогии с неблочным методом умножение на $d_i$ за операцию не считаем). \\
    
    Тогда для вычисления $R_{ji}^T D_j R_{js}$ требуется 
    $$
        \sum_{i=1}^m \sum_{j=1}^m (2min(i,j) - 1) =
        \sum_{i=1}^m \sum_{j=1}^i (2j - 1) + 
        \sum_{i=1}^m \sum_{j=i+1}^m (2i - 1) = $$$$
        \frac{m(m+1)(2m+1)}6 + \frac{m(2m^2-3m+1)}6 = 
        \frac{m(2m^2+1)}3 
    $$
    
    Обозначим как $ Mult(m) = (2m^3+m)/3 $. \\ \\
    
    Для вычисления $A_{is} - \sum_{k=1}^{i-1}R_{ji}^T D_j R_{js}$ требуется: 
    $$
        H(i,m) = 
        (i-1)(Mult(m)+m^2) = 
        (i-1)(2m^3+3m^2+m)/3 
        \quad \text{операций.}
    $$  
    Сложность разложения Холецкого $Chol(m) = m^3/3$. \\
    Cложность вычисления блока $R_{ii}$ и $D_i$ : $H(i,m) + Chol(m)$ \\
    \hypertarget{block_border}{Сложность вычисления всех диагональных блоков:}
    $$ 
        S_1(n,m,k) = 
        \sum_{i=1}^k (H(i,m) + Chol(m)) =
        n(2mn + 3n + k - 3m -1)/6
    $$
    \\
    
    Умножение на треугольную матрицу требует $Y(m)=m^3$ операций.
    Здесь имеется ввиду умножение на $(R_{ii}^T)^{-1}$ в формуле~\eqref{block_is}. 
    Подсчёт обратной к $R_{ii}^T$ учтёем позже, так как это вычисление выполняется 
    1 раз при подсчете всей строки. \\
    
    Итак, сложность вычисления недиагонального блока $R_{ij}$:
    $$ 
        R(i,m) = H(i,m) + Y(m) =
        (i-1)(2m^3+3m^2+m)/3 + m^3
    $$
    
    Cложность вычисления всех недиагональных блоков $R$:
    $$ 
        S_2(n,m,k) = 
        \sum_{i=1}^k\sum_{s=i+1}^k R(i,m) =
        n(k-1)(2mn+3n+k+5m^2-6m-2)/18
    $$
    
    Для вычисления строки - $R_{ij}$ при фиксированном $i$ требуется $(R_{ii}^T)^{-1}$,
    следовательно нужно $(k-1)$ раз найти обратную матрицу за \\
    $S_3(n, m) = (k-1)Chol(m) = (k-1)m^3/3$ операций. \\
    
    Итак, нахождение всех блоков $R_{is}$ требует
    $$
        S(n, m)= S_1 + S_2 + S_3 = 
        \frac{n(2mn + 3n + k - 3m -1)}6 + $$$$ +
        \frac{n(k-1)(2mn+3n+k+5m^2-6m-2)}{18} +
        \frac{(k-1)m^3}3 = $$$$ =
        \frac{n(2n^2+m^2+9mn-3m-1+3nk+k^2)}{18} - \frac{m^3}3 = $$$$ =
        \boxed {
            \frac{n^3}9 + \frac{nm^2}{18} + \frac{n^2m}2 - \frac{nm}6 -
            \frac{n}{18} + \frac{n^3}{6m} + \frac{n^3}{18m^2} - \frac{m^3}3  }
    $$
    
    $$ 
        S(n,n) =
        \frac{n^3}9 + \frac{n^3}{18} + \frac{n^3}2 - \frac{n^2}6 - 
        \frac{n}{18} + \frac{n^2}6 + \frac{n}{18} - \frac{n^3}3 = 
        \frac{n^3}3
    $$
    $$
        S(n,1) = 
        \frac{n^3}9 + \frac{n}{18} + \frac{n^2}3 - \frac{n}6 -
        \frac{n}{18} + \frac{n^3}6 + \frac{n^3}{18} - \frac{1}3 =
        \frac{n^3}3 + \frac{n^2}3 - \frac{n}6
    $$
    
    $$
        \boxed {
            S(n,n) = \frac{n^3}3 \quad 
            S(n,1) = \frac{n^3}3 + O(n^2),\ n \to \infty   }
    $$
    
    


% Глава3
\newpage
\section{Параллельный блочный метод Холецкого}
\subsection{Описание параллельного блочного разложения Холецкого}
    Из формул~\eqref{block_i} и~\eqref{block_is} видно, что после вычисления диагольного 
    блока и его обращения все блоки вне диагонали можно искать в любом порядке в 
    контексте текущей строки. \\
    
    Пусть $p$ --- количество потоков. Принадлежность столбца потоку определяется так:
    $s$-ый поток обрабатывает столбцы с номерами $s + zp$, где $z \in \mathbb{Z}$. \\
    
    Для вычислени $R_{is}$ ребуются блоки из столбцов $i$ и $s$, находящиеся строго в предыдущих строках. 
    При чем $s$-ый столбец считается «своим», а $i$-ый принадлежит 
    другому потоку, поэтому предалагается каждому потоку иметь копию столбца $i$. \\
    
    Барьеры используются для корректного копирования данных из общей памяти (матрицы $A$),
    соотвественно до и после этой операции. \\
    
    Таким образом, имеем 
    \hypertarget{paral_alg}{следующий параллельный алгоритм}: 

\begin{verbatim}
for (i = 0; i < block_lim; i++)
  {
    Barrier
    get diag block R_{ii} and i-th column
    Barrier
    
    calculate diag block R_{ii}
    inverse diag block R_{ii}
    
    if (i % th_p == th_i)
      put diag block R_{ii} and block D_{i}
        
    if (i % th_p < th_i)
      j = i - (i % p) + th_i;
    else
      j = i - (i % p) + p + th_i;
        
    for (; j < block_lim; j += th_p)
      {
        get block R_{ij}
        calculate block R_{ij}
        put block R_{ij}
      }
  }
\end{verbatim}


\subsection{Описание параллельного решения систем $R^T y = b$ и $DRx = y$}

    Описанный выше 
    \hyperlink{calc_y}{линейный алгоритм решения системы $R^T y = b$} 
    имеет особенность - для вычисления $y[i]$ 
    \hypertarget{reason}{требуются готовые значения всех предыдущих компонент}, 
    то есть $y[j],\, j = 0 \dots i-1$, что для паралельной реализации недопустимо. \\
    
    По аналогии с параллельным блочным разложением определим принадлежность данных потоку.
    Пусть $p$ --- количество потоков, $i$-ый блок вектора $b$ принадлежит потоку 
    с номером $i\,\%\, p$. \\
    
    Заметим, что в СЛУ матрица $R$ транспонироана, поэтому при умножении на блоки $R$ 
    всегда подразумевается операция с транспонированным блоком. 
    К тому же, обратный ход Гаусса выполняется с вычитанием не строк, а столбцов. \\
    
    Получается следующий \hypertarget{th_calc_y}{параллельный алгоритм}: 
    
\begin{verbatim}
for (i = 0; i < block_lim; i++)
  {
    Barrier
    get diag block R_{ii} and block B_{i}
    Barrier
    
    inverse diag block R_{ii}
    calculate inv_R_{ii}^T * B_{i} -> B_diff

    if (i % th_p < th_i)
      s = i - (i % th_p) + th_i;
    else
      s = i - (i % th_p) + th_p + th_i;

    for (; s < block_lim; s += th_p)
      {
        get block R_{is} 
        get block B_{s}
        calculate B_{s} - R_{is}^T * (B_diff)
        put block B_{s}
      }

    if (i % th_p == th_i)
      put changed block B_{i}
    }
\end{verbatim}

    Описанный выше 
    \hyperlink{calc_x}{линейный алгоритм решения системы $DRx = y$} 
    по той же \hyperlink{reason}{причине} не можем использовать. \\
    
    Перед началом решения паралельно умножит вектор $y$ на $D^{-1} = D$.
    На $i$-ой итерации обратного хода потоки будут вычислять изменение текущего блока $Y[i]$ 
    (за счет условного вычитания строк) и складывать результат в разделяемый буферный блочный вектор $S$. 
    После поток с номером $i\,\%\, p$ соберет эти изменения и применит к блоку $Y[i]$. \\
    
    Таким образом, получаем следующий параллельный алгоритм: 

\begin{verbatim}
for (i = 0; i < block_lim; i++)
  {
    if (i % th_p < th_i)
      s = i + (i % th_p) - th_i;
    else
      s = i + (i % th_p) - th_p - th_i;

    bzero B_diff
    for (; s >= 0; s -= th_p)
      {
        get block R_{is}
        get block B_{s}
        calculate - R_{is} * B_{s} -> B_diff
      }
    put_block B_diff -> S
    Barrier
      
    if (i % th_p == th_i)
      {
        get diag block R_{ii}
        get block B_{i} -> B_diff
        inverse diag block R_{ii}

        /* get total B_diff */
        for (j = 0; j < block_size; j ++)
          {
            sum = 0;
            for (s = 0; s < th_p; s++)
              sum += S[j + s * block_size];
            B_diff[j] += sum;
          }

        calculate  inv_R_{ii} * B_{i}
        put changed block B_{i}
      }
    Barrier
  }
\end{verbatim}


\subsection{Оценка числа точек синхронизаций}
    Считаем, что $n = mk + l,\; l = 0$.\\
    
    Разложение матрицы методом Холецкого требует $2k$ барьеров.
    При решении систем $R^T y = b$ и $DRx = y$ используется по $2k$ точек синхронизации.
    Причем каждый поток использует только свою память.\\
    
    Таким образом, в параллельном алгоритме $3k$ точек синхронизаций.
    

\newpage
\subsection{Оценка сложности в алгоритме построения верхнетреугольной матрицы
в параллельном блочном разложении Холецкого}
    Из \hyperlink{paral_alg}{приведенного выше алгоритма} видно, что все потоки 
    вычисляют совпадающие диагональные блоки и обратные к ним, поэтому 
    $$
        S_1(n,m,p) = S_1(n,m) \quad \text{и} \quad S_3(n,m,p) = S_3(n,m)
    $$
    Эти формулы из \hyperlink{block_border}{оценки блочного алгоритма.} \\
    
    Вычисление внедиагональных блоков происходит полностью параллельно, поэтому 
    $ S_2(n,m,p) = S_2(n,m)/p $ \\

    Итак, 
    $$
        S(n,m,p) = S_1 + \frac{S_2}{p} + S_3 = 
        \frac{n(2mn + 3n + k - 3m -1)}6 \,+ $$$$ +\,
        \frac{n(k-1)(2mn+3n+k+5m^2-6m-2)}{18p} +
        \frac{(k-1)m^3}3 = $$$$ =
        \frac{n^3}9 + \frac{n^2m}{6p} + \frac{n^2m}{3} +
        \frac{nm^2}3 - \frac{5nm^2}{18p} - \frac{m^3}3 +
        \frac{n^2}2 - \frac{n^2}{2p} - \frac{nm}2 + \frac{nm}{3p} - $$$$ -
        \frac{n}6 + \frac{n}{9p} + \frac{n^3}{6pm} + \frac{n^3}{18pm^2} +
        \frac{n^2}{6m} - \frac{n^2}{6pm}
    $$ \\
    
    Причем $S(n,m,1) = S(n,m)$




% Глава4
\newpage
\section{MPI блочный метод Холецкого}
\subsection{Хранение данных для MPI-реализации блочного разложения Холецкого}
    Отличие MPI-реализации от параллельной блочной, использующей потоки,
    заключается в том, что из одного процесса невозможно иметь доступ
    ко всей матрице. \\
    
    Процесс с номером $my\_rank$ считает «своими» блок-столбцы с номером $i\_glob$, 
    для которых выполнено $my\_rank = i\_glob \,\%\, comm\_size$,
    и выделяет для них память.\\
    
    Для упрощения перевода глобальной индексации в локальную, предлагается в процессах
    выделить память под свою часть матрицы и завести массив указателей на начало каждого 
    блок-столбца в текущем процессе и инициализировать матрицу относительно него. 
    Тогда преобразование \textbf{блочной} индексации будет выглядеть следующим образом:
    \begin{verbatim}
    i_loc = i_glob
    j_loc = j_glob / comm_size
    
    i_glob = i_loc
    j_glob = j_loc * comm_size + my_rank
    \end{verbatim}
    
    
\subsection{Описание MPI блочного разложения Холецкого}
    Для вычислени $R_{is}$ (для матрицы $R$ всегда имеется ввиду глобальная нумерация) 
    требуются блоки из столбцов $i$ и $s$, находящиеся строго в предыдущих строках. 
    Причем $s$-ый столбец считается «своим», а $i$-ый принадлежит 
    другому процессу, поэтому «хозяин» рассылкает каждому процессу столбец $i$. \\
    
    У каждого процесса имеется свой экземпляр матрицы $D$.
    Каждый проесс, имеея столбец $i$, может самомстоятельно посчитать разложение Холецого диагольного 
    блока $R_{ii}$. Затем обратить его для последубщего использования и обновить соответсвующий ему блок матрицы $D$.
    
    Таким образом, имеем 
    \hypertarget{mpi_alg}{следующий алгоритм}: 

\begin{verbatim}

for (i_glob = 0; i_glob < block_lim; i_glob++)
  {
    if (is_my_column (i_glob))
      copy i_glob-th column to buf_column
    
    MPI_Bcast (buf_column, m * m * (i_glob + 1), MPI_DOUBLE, 
               column_owner (i_glob), MPI_COMM_WORLD);

    diag block R_{ii} := buf_column + m * m * i_glob
    calculate diag block R_{ii}
    inverse diag block R_{ii}

    if (is_my_column (i_glob))
      put diag block R_{ii}
        
    for (j_glob = i_glob + 1; j < block_lim; j++)
      if (is_my_column (j_glob))
        calculate block R_{ij}
  }
\end{verbatim}


%\newpage
\subsection{Описание MPI-решения систем $R^T y = b$ и $DRx = y$}

    У каждого процесса храниться копия вектора $b$ и как результат разложения все 
    обратные к диагольным блокам матрицы $R$, что будет использоваться при решении систем.\\
    
    MPI-алгоритм решения системы $R^T y = b$:
    
\begin{verbatim}
for (i_glob = 0; i_glob < block_lim; i_glob++)
  {
    column_lim := m or n%m for last block
    if (is_my_column (i_glob))
      Y{i_glob} = B{i_glob} * inv_R_{ii}
     
    MPI_Bcast (Y{i_glob}, column_lim, MPI_DOUBLE, 
               column_owner (i_glob), MPI_COMM_WORLD);
              
    for (s_glob = i_glob; s_glob < block_lim; s_glob++)          
      if (is_my_column (s_glob))
        B{i_glob} -= R_{is}^T * Y{i_glob}
  }
\end{verbatim}

    MPI-алгоритм решения системы $DRx = y$:

\begin{verbatim}
for (i_glob = block_lim - 1; i_glob >= 0; i_glob--)
 {
    column_lim := m or n%m for last block
    if (is_my_column (i_glob))
      {
        copy i_glob-th column to buf_column
        X{i_glob} = Y{i_glob} * inv_R_{ii}
      }
     
    MPI_Bcast (X{i_glob}, column_lim, MPI_DOUBLE, 
               column_owner (i_glob), MPI_COMM_WORLD);

    MPI_Bcast (buf_column, m * m * (i_glob + 1), MPI_DOUBLE, 
               column_owner (i_glob), MPI_COMM_WORLD);
              
    for (s_glob = 0; s_glob < i_glob; s_glob++)          
      if (is_my_column (s_glob))
        Y{i_glob} -= X{i_glob} * buf_column_{s_glob} /* R_{si} */
 }
\end{verbatim}
    
    
\newpage
\subsection{Оценка сложности MPI-реализаии решения СЛУ методом Холецкого}

    Оценим число пекресылок между процессами и объем пересылаемых данных.
    Будем считать, что $l = 0$, где $n = m * k + l$.
    
    \begin{itemize}
        \item В разложении:
        \begin{itemize}
            \item $k$ пересылок - будет разослана всем каждый блочный столбец,
            \item общий объем пересылаемых данных будет $n*(n+1)/2$, то есть равен размеру матрицы.
        \end{itemize}
        \item При вычеслении вектора $y$:
        \begin{itemize}
            \item $k$ пересылок - будет разослан всем каждый новый посчитанный блок,
            \item общий объем пересылаемых данных будет $n$, то есть равен размеру вектора.
        \end{itemize}
        \item При вычеслении вектора $x$:
        \begin{itemize}
            \item $k + k$ пересылок - будет разослан всем каждый новый посчитанный блок
            и текущий блочный столбец матрицы,
            \item общий объем пересылаемых данных будет $n + n*(n+1)/2$, 
            то есть равен размеру матрицы + размер вектора.
        \end{itemize}
        \item Всего:
        \begin{itemize}
            \item $4k$ пересылок,
            \item общий объем пересылаемых данных равен $n*(n+3)$.
        \end{itemize}
    \end{itemize}
    
    \bigskip
    Оценим расходуемый объём памяти. На один процесс имеем:
    \begin{itemize}
        \item хранение матрицы $D$ --- $n$,
        \item хранение векторов $b, x$  --- $2* n$, \\
        при решении второй системы вектора $b$ и $x$ меняются ролями,
        \item хранение обратных матриц к диагольным блокам --- $k * (m * m)$.
        \item использование буферной блочной строки  --- $n * m$.
        \item использование вспомиогательных блоков  --- $2 * m * m$.
    \end{itemize}
    
    Итого, $3n + 2nm + 2m^2$ на каждый процесс. \\
    К этому следует учесть хранение матрицы $A$ --- $n*(n+1)/2$ в общем объёме на все процессы. \\
    
    По сравнению с параллельной версией количество операций для MPI-реализации 
    разложения Холецкого не изменилось.
\end{document}


